# ADesk - 轻量级Android桌面启动器

## 项目概述

ADesk是一个针对Android 4.1+的轻量级桌面启动器，专为小屏手机和智能手表设计。

### 主要功能
- **主页**：时钟、日期、日历事件、快捷应用
- **应用列表**：显示所有应用，支持多种排序方式
- **搜索页面**：按字母分组的网格布局搜索
- **收藏管理**：收藏常用应用
- **自定义排序**：拖拽排序应用顺序
- **隐藏应用**：隐藏不想显示的应用

---

## 核心文件结构

```
app/src/main/java/com/thanksplay/adesk/
├── model/
│   └── AppInfo.kt              # 应用数据模型
├── util/
│   ├── AppLoader.kt            # 应用加载器
│   └── PreferencesManager.kt   # 设置管理器
├── adapter/
│   ├── AppAdapter.kt           # 应用列表适配器
│   ├── SearchAppAdapter.kt     # 搜索页面适配器
│   ├── HomeAppAdapter.kt       # 主页应用适配器
│   └── DesktopPagerAdapter.kt  # ViewPager适配器
└── ui/
    ├── MainActivity.kt         # 主Activity
    ├── SettingsActivity.kt     # 设置页面
    ├── CustomOrderActivity.kt  # 自定义排序
    ├── FavoritesActivity.kt    # 收藏管理
    ├── HiddenAppsActivity.kt   # 隐藏应用管理
    └── HomeAppsActivity.kt     # 主页应用管理
```

---

## 核心代码

### 1. AppInfo.kt - 数据模型

```kotlin
package com.thanksplay.adesk.model

import android.graphics.drawable.Drawable

data class AppInfo(
    val packageName: String,
    val className: String,
    val label: String,
    val icon: Drawable,
    val installTime: Long
)
```

### 2. PreferencesManager.kt - 设置管理

```kotlin
package com.thanksplay.adesk.util

import android.content.Context
import android.content.SharedPreferences

class PreferencesManager(context: Context) {
    
    private val prefs: SharedPreferences = 
        context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
    
    var columnsPerPage: Int
        get() = prefs.getInt(KEY_COLUMNS_PER_PAGE, DEFAULT_COLUMNS)
        set(value) = prefs.edit().putInt(KEY_COLUMNS_PER_PAGE, value).apply()
    
    var labelPosition: Int
        get() = prefs.getInt(KEY_LABEL_POSITION, LABEL_POSITION_RIGHT)
        set(value) = prefs.edit().putInt(KEY_LABEL_POSITION, value).apply()
    
    var sortMethod: Int
        get() = prefs.getInt(KEY_SORT_METHOD, SORT_ABC)
        set(value) = prefs.edit().putInt(KEY_SORT_METHOD, value).apply()
    
    var favoriteApps: Set<String>
        get() = prefs.getStringSet(KEY_FAVORITE_APPS, emptySet()) ?: emptySet()
        set(value) = prefs.edit().putStringSet(KEY_FAVORITE_APPS, value).apply()
    
    var hiddenApps: Set<String>
        get() = prefs.getStringSet(KEY_HIDDEN_APPS, emptySet()) ?: emptySet()
        set(value) = prefs.edit().putStringSet(KEY_HIDDEN_APPS, value).apply()
    
    var customOrder: String
        get() = prefs.getString(KEY_CUSTOM_ORDER, "") ?: ""
        set(value) = prefs.edit().putString(KEY_CUSTOM_ORDER, value).apply()
    
    var showFavoritesOnly: Boolean
        get() = prefs.getBoolean(KEY_SHOW_FAVORITES_ONLY, false)
        set(value) = prefs.edit().putBoolean(KEY_SHOW_FAVORITES_ONLY, value).apply()
    
    var searchColumns: Int
        get() = prefs.getInt(KEY_SEARCH_COLUMNS, DEFAULT_SEARCH_COLUMNS)
        set(value) = prefs.edit().putInt(KEY_SEARCH_COLUMNS, value).apply()
    
    var homeApps: String
        get() = prefs.getString(KEY_HOME_APPS, "") ?: ""
        set(value) = prefs.edit().putString(KEY_HOME_APPS, value).apply()
    
    var homeColumns: Int
        get() = prefs.getInt(KEY_HOME_COLUMNS, DEFAULT_HOME_COLUMNS)
        set(value) = prefs.edit().putInt(KEY_HOME_COLUMNS, value).apply()
    
    var homeRows: Int
        get() = prefs.getInt(KEY_HOME_ROWS, DEFAULT_HOME_ROWS)
        set(value) = prefs.edit().putInt(KEY_HOME_ROWS, value).apply()
    
    fun addFavoriteApp(packageName: String) {
        val favorites = favoriteApps.toMutableSet()
        favorites.add(packageName)
        favoriteApps = favorites
    }
    
    fun removeFavoriteApp(packageName: String) {
        val favorites = favoriteApps.toMutableSet()
        favorites.remove(packageName)
        favoriteApps = favorites
    }
    
    fun isFavorite(packageName: String): Boolean {
        return favoriteApps.contains(packageName)
    }
    
    fun hideApp(packageName: String) {
        val hidden = hiddenApps.toMutableSet()
        hidden.add(packageName)
        hiddenApps = hidden
    }
    
    fun showApp(packageName: String) {
        val hidden = hiddenApps.toMutableSet()
        hidden.remove(packageName)
        hiddenApps = hidden
    }
    
    fun isHidden(packageName: String): Boolean {
        return hiddenApps.contains(packageName)
    }
    
    companion object {
        private const val PREFS_NAME = "adesk_prefs"
        private const val KEY_COLUMNS_PER_PAGE = "columns_per_page"
        private const val KEY_LABEL_POSITION = "label_position"
        private const val KEY_SORT_METHOD = "sort_method"
        private const val KEY_FAVORITE_APPS = "favorite_apps"
        private const val KEY_HIDDEN_APPS = "hidden_apps"
        private const val KEY_CUSTOM_ORDER = "custom_order"
        private const val KEY_SHOW_FAVORITES_ONLY = "show_favorites_only"
        private const val KEY_SEARCH_COLUMNS = "search_columns"
        private const val KEY_HOME_APPS = "home_apps"
        private const val KEY_HOME_COLUMNS = "home_columns"
        private const val KEY_HOME_ROWS = "home_rows"
        
        const val DEFAULT_COLUMNS = 2
        const val DEFAULT_SEARCH_COLUMNS = 6
        const val DEFAULT_HOME_COLUMNS = 4
        const val DEFAULT_HOME_ROWS = 2
        const val LABEL_POSITION_RIGHT = 0
        const val LABEL_POSITION_BOTTOM = 1
        
        const val SORT_ABC = 0
        const val SORT_INSTALL_TIME = 1
        const val SORT_CUSTOM = 2
    }
}
```

### 3. AppLoader.kt - 应用加载

```kotlin
package com.thanksplay.adesk.util

import android.content.Context
import android.content.Intent
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import com.thanksplay.adesk.model.AppInfo

class AppLoader(private val context: Context) {
    
    fun loadAllApps(): List<AppInfo> {
        val pm = context.packageManager
        val intent = Intent(Intent.ACTION_MAIN, null).apply {
            addCategory(Intent.CATEGORY_LAUNCHER)
        }
        
        val resolveInfoList = pm.queryIntentActivities(intent, 0)
        
        return resolveInfoList
            .filter { it.activityInfo.applicationInfo.flags and ApplicationInfo.FLAG_SYSTEM == 0 }
            .map { resolveInfo ->
                val activityInfo = resolveInfo.activityInfo
                AppInfo(
                    packageName = activityInfo.packageName,
                    className = activityInfo.name,
                    label = resolveInfo.loadLabel(pm).toString(),
                    icon = resolveInfo.loadIcon(pm),
                    installTime = try {
                        pm.getPackageInfo(activityInfo.packageName, 0).firstInstallTime
                    } catch (e: Exception) { 0L }
                )
            }
    }
    
    fun sortApps(apps: List<AppInfo>, sortMethod: Int, customOrder: String): List<AppInfo> {
        return when (sortMethod) {
            0 -> apps.sortedBy { it.label.lowercase() }
            1 -> apps.sortedByDescending { it.installTime }
            2 -> {
                if (customOrder.isNotEmpty()) {
                    val orderList = customOrder.split(",")
                    val orderedApps = orderList.mapNotNull { packageName ->
                        apps.find { it.packageName == packageName }
                    }
                    val remainingApps = apps.filter { app ->
                        !orderList.contains(app.packageName)
                    }.sortedBy { it.label.lowercase() }
                    orderedApps + remainingApps
                } else {
                    apps.sortedBy { it.label.lowercase() }
                }
            }
            else -> apps.sortedBy { it.label.lowercase() }
        }
    }
}
```

### 4. MainActivity.kt - 主Activity（核心逻辑）

```kotlin
package com.thanksplay.adesk.ui

import android.Manifest
import android.app.AlertDialog
import android.content.Intent
import android.content.pm.PackageManager
import android.database.Cursor
import android.os.Bundle
import android.provider.CalendarContract
import android.text.Editable
import android.text.TextWatcher
import android.view.LayoutInflater
import android.view.View
import android.view.inputmethod.InputMethodManager
import android.widget.EditText
import android.widget.LinearLayout
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import androidx.viewpager2.widget.ViewPager2
import com.thanksplay.adesk.R
import com.thanksplay.adesk.adapter.AppAdapter
import com.thanksplay.adesk.adapter.DesktopPagerAdapter
import com.thanksplay.adesk.adapter.HomeAppAdapter
import com.thanksplay.adesk.adapter.SearchAppAdapter
import com.thanksplay.adesk.model.AppInfo
import com.thanksplay.adesk.util.AppLoader
import com.thanksplay.adesk.util.PreferencesManager
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Date
import java.util.Locale

class MainActivity : AppCompatActivity(), AppAdapter.OnAppActionListener {
    
    private lateinit var viewPager: ViewPager2
    private lateinit var pageIndicator: LinearLayout
    private lateinit var prefsManager: PreferencesManager
    private lateinit var appLoader: AppLoader
    
    private var allApps: List<AppInfo> = emptyList()
    private var displayedApps: List<AppInfo> = emptyList()
    
    private lateinit var appsRecyclerView: RecyclerView
    private lateinit var searchRecyclerView: RecyclerView
    private lateinit var searchInput: EditText
    
    private lateinit var tvTime: TextView
    private lateinit var tvDate: TextView
    private lateinit var tvEvent: TextView
    private lateinit var homeAppsRecyclerView: RecyclerView
    
    private lateinit var appsAdapter: AppAdapter
    private lateinit var searchAdapter: SearchAppAdapter
    private lateinit var homeAppsAdapter: HomeAppAdapter
    
    private val timeFormat = SimpleDateFormat("HH:mm", Locale.getDefault())
    private val dateFormat = SimpleDateFormat("yyyy年MM月dd日 EEEE", Locale.CHINA)
    
    private val timeUpdateRunnable = object : Runnable {
        override fun run() {
            updateTime()
            android.os.Handler(mainLooper).postDelayed(this, 1000)
        }
    }
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        prefsManager = PreferencesManager(this)
        appLoader = AppLoader(this)
        
        initViews()
        loadApps()
    }
    
    private fun initViews() {
        viewPager = findViewById(R.id.viewPager)
        pageIndicator = findViewById(R.id.pageIndicator)
        
        val pages = createPages()
        val pagerAdapter = DesktopPagerAdapter(pages)
        viewPager.adapter = pagerAdapter
        
        viewPager.registerOnPageChangeCallback(object : ViewPager2.OnPageChangeCallback() {
            override fun onPageSelected(position: Int) {
                updatePageIndicator(position)
                showPageIndicator()
                when (position) {
                    0 -> { }
                    1 -> { }
                    2 -> {
                        searchInput.requestFocus()
                        searchAdapter.setItems(allApps.filter { !prefsManager.hiddenApps.contains(it.packageName) })
                    }
                }
                if (position != 2) {
                    hideKeyboard()
                }
            }
        })
        
        android.os.Handler(mainLooper).post(timeUpdateRunnable)
    }
    
    private fun showPageIndicator() {
        pageIndicator.visibility = View.VISIBLE
        pageIndicator.animate().alpha(1f).setDuration(200).start()
        android.os.Handler(mainLooper).postDelayed({
            pageIndicator.animate().alpha(0f).setDuration(500).withEndAction {
                pageIndicator.visibility = View.INVISIBLE
            }.start()
        }, 2000)
    }
    
    private fun createPages(): List<View> {
        val inflater = LayoutInflater.from(this)
        val pages = mutableListOf<View>()
        
        // 主页
        val homePage = inflater.inflate(R.layout.page_home, viewPager, false)
        tvTime = homePage.findViewById(R.id.tvTime)
        tvDate = homePage.findViewById(R.id.tvDate)
        tvEvent = homePage.findViewById(R.id.tvEvent)
        homeAppsRecyclerView = homePage.findViewById(R.id.homeAppsRecyclerView)
        
        val homeColumns = prefsManager.homeColumns
        homeAppsRecyclerView.layoutManager = GridLayoutManager(this, homeColumns)
        homeAppsAdapter = HomeAppAdapter(this)
        homeAppsRecyclerView.adapter = homeAppsAdapter
        pages.add(homePage)
        
        // 应用列表
        val appsPage = inflater.inflate(R.layout.page_apps, viewPager, false)
        appsRecyclerView = appsPage.findViewById(R.id.appsRecyclerView)
        updateLayoutManager()
        appsAdapter = AppAdapter(this, prefsManager)
        appsAdapter.setOnSettingsClickListener { openSettings() }
        appsRecyclerView.adapter = appsAdapter
        pages.add(appsPage)
        
        // 搜索页面
        val searchPage = inflater.inflate(R.layout.page_search, viewPager, false)
        searchRecyclerView = searchPage.findViewById(R.id.searchResultsRecyclerView)
        val searchColumns = prefsManager.searchColumns
        val gridLayoutManager = GridLayoutManager(this, searchColumns)
        searchAdapter = SearchAppAdapter(this, searchColumns)
        gridLayoutManager.spanSizeLookup = object : GridLayoutManager.SpanSizeLookup() {
            override fun getSpanSize(position: Int): Int {
                return searchAdapter.getSpanSize(position)
            }
        }
        searchRecyclerView.layoutManager = gridLayoutManager
        searchRecyclerView.adapter = searchAdapter
        
        searchInput = searchPage.findViewById(R.id.searchInput)
        searchInput.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}
            override fun afterTextChanged(s: Editable?) {
                filterApps(s?.toString() ?: "")
            }
        })
        pages.add(searchPage)
        
        return pages
    }
    
    private fun updateTime() {
        val now = Date()
        tvTime.text = timeFormat.format(now)
        tvDate.text = dateFormat.format(now)
    }
    
    private fun loadHomeApps() {
        val homeAppsOrder = prefsManager.homeApps
        val maxApps = prefsManager.homeColumns * prefsManager.homeRows
        
        if (homeAppsOrder.isNotEmpty()) {
            val orderList = homeAppsOrder.split(",").filter { it.isNotEmpty() }
            val homeApps = orderList.mapNotNull { packageName ->
                allApps.find { it.packageName == packageName }
            }.take(maxApps)
            homeAppsAdapter.setItems(homeApps)
        } else {
            val hiddenApps = prefsManager.hiddenApps
            val defaultApps = allApps
                .filter { !hiddenApps.contains(it.packageName) }
                .sortedBy { it.label.lowercase() }
                .take(maxApps)
            homeAppsAdapter.setItems(defaultApps)
        }
    }
    
    private fun filterApps(query: String) {
        val hiddenApps = prefsManager.hiddenApps
        val appsToSearch = allApps.filter { !hiddenApps.contains(it.packageName) }
        
        if (query.isEmpty()) {
            searchAdapter.setItems(appsToSearch)
            return
        }
        
        val filtered = appsToSearch.filter { 
            it.label.lowercase().contains(query.lowercase()) 
        }
        searchAdapter.setItems(filtered)
    }
    
    private fun updatePageIndicator(position: Int) {
        for (i in 0 until pageIndicator.childCount) {
            val indicator = pageIndicator.getChildAt(i)
            val drawableRes = if (i == position) {
                R.drawable.indicator_selected
            } else {
                R.drawable.indicator_unselected
            }
            indicator.setBackgroundResource(drawableRes)
        }
    }
    
    override fun onResume() {
        super.onResume()
        loadApps()
        updateTime()
    }
    
    override fun onDestroy() {
        super.onDestroy()
        android.os.Handler(mainLooper).removeCallbacks(timeUpdateRunnable)
    }
}
```

### 5. SearchAppAdapter.kt - 搜索适配器（带字母分界线）

```kotlin
package com.thanksplay.adesk.adapter

import android.content.Context
import android.content.Intent
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.TextView
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.thanksplay.adesk.R
import com.thanksplay.adesk.model.AppInfo

class SearchAppAdapter(
    private val context: Context,
    private val columns: Int = 6
) : RecyclerView.Adapter<RecyclerView.ViewHolder>() {
    
    companion object {
        private const val TYPE_HEADER = 0
        private const val TYPE_APP = 1
    }
    
    private var items: MutableList<ListItem> = mutableListOf()
    
    fun setItems(apps: List<AppInfo>) {
        val sortedApps = apps.sortedBy { it.label.lowercase() }
        items.clear()
        
        var lastSection = ""
        sortedApps.forEach { app ->
            val firstChar = app.label.firstOrNull()?.uppercase() ?: "#"
            if (firstChar != lastSection) {
                items.add(ListItem.Header(firstChar))
                lastSection = firstChar
            }
            items.add(ListItem.AppItem(app))
        }
        
        notifyDataSetChanged()
    }
    
    override fun getItemViewType(position: Int): Int {
        return when (items[position]) {
            is ListItem.Header -> TYPE_HEADER
            is ListItem.AppItem -> TYPE_APP
        }
    }
    
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
        return when (viewType) {
            TYPE_HEADER -> {
                val view = LayoutInflater.from(parent.context)
                    .inflate(R.layout.item_section_header, parent, false)
                HeaderViewHolder(view)
            }
            else -> {
                val view = LayoutInflater.from(parent.context)
                    .inflate(R.layout.item_search_app_grid, parent, false)
                AppViewHolder(view)
            }
        }
    }
    
    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
        when (val item = items[position]) {
            is ListItem.Header -> {
                (holder as HeaderViewHolder).headerText.text = item.letter
            }
            is ListItem.AppItem -> {
                val appHolder = holder as AppViewHolder
                appHolder.icon.setImageDrawable(item.app.icon)
                appHolder.label.text = item.app.label
                appHolder.itemView.setOnClickListener {
                    launchApp(item.app)
                }
            }
        }
    }
    
    override fun getItemCount(): Int = items.size
    
    private fun launchApp(app: AppInfo) {
        try {
            val intent = Intent(Intent.ACTION_MAIN).apply {
                setClassName(app.packageName, app.className)
                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            }
            context.startActivity(intent)
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
    
    fun getSpanSize(position: Int): Int {
        return when (items[position]) {
            is ListItem.Header -> columns
            is ListItem.AppItem -> 1
        }
    }
    
    private sealed class ListItem {
        data class Header(val letter: String) : ListItem()
        data class AppItem(val app: AppInfo) : ListItem()
    }
    
    inner class HeaderViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        val headerText: TextView = itemView.findViewById(R.id.headerText)
    }
    
    inner class AppViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        val icon: ImageView = itemView.findViewById(R.id.appIcon)
        val label: TextView = itemView.findViewById(R.id.appLabel)
    }
}
```

---

## 布局文件

### activity_main.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#000000">

    <androidx.viewpager2.widget.ViewPager2
        android:id="@+id/viewPager"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

    <LinearLayout
        android:id="@+id/pageIndicator"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="bottom|center_horizontal"
        android:layout_marginBottom="16dp"
        android:orientation="horizontal"
        android:gravity="center"
        android:alpha="0"
        android:visibility="invisible">

        <View android:id="@+id/indicator0" ... />
        <View android:id="@+id/indicator1" ... />
        <View android:id="@+id/indicator2" ... />

    </LinearLayout>

</FrameLayout>
```

### page_home.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:gravity="center_horizontal"
    android:padding="16dp"
    android:paddingBottom="48dp"
    android:background="#000000">

    <View android:layout_weight="1" ... />

    <TextView android:id="@+id/tvTime" ... />
    <TextView android:id="@+id/tvDate" ... />
    <TextView android:id="@+id/tvEvent" ... />

    <View android:layout_weight="1" ... />

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/homeAppsRecyclerView" ... />

</LinearLayout>
```

---

## AndroidManifest.xml

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.QUERY_ALL_PACKAGES"
        tools:ignore="QueryAllPackagesPermission" />
    <uses-permission android:name="android.permission.READ_CALENDAR" />

    <application ...>
        <activity
            android:name=".ui.MainActivity"
            android:exported="true"
            android:launchMode="singleTask">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.HOME" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        
        <activity android:name=".ui.SettingsActivity" ... />
        <activity android:name=".ui.CustomOrderActivity" ... />
        <activity android:name=".ui.FavoritesActivity" ... />
        <activity android:name=".ui.HiddenAppsActivity" ... />
        <activity android:name=".ui.HomeAppsActivity" ... />
    </application>

</manifest>
```

---

## build.gradle (app level)

```gradle
plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
}

android {
    namespace 'com.thanksplay.adesk'
    compileSdk 34

    defaultConfig {
        applicationId "com.thanksplay.adesk"
        minSdk 16
        targetSdk 34
        versionCode 1
        versionName "1.0"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
    kotlinOptions {
        jvmTarget = '1.8'
    }
}

dependencies {
    implementation 'androidx.core:core-ktx:1.12.0'
    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'androidx.viewpager2:viewpager2:1.0.0'
    implementation 'androidx.recyclerview:recyclerview:1.3.2'
}
```

---

## 待优化项

1. **性能优化**
   - 应用列表加载优化
   - 图片缓存机制
   - 内存管理

2. **功能增强**
   - 拖拽排序主页应用
   - 更多主页布局选项
   - 主题切换

3. **UI改进**
   - 动画效果
   - 过渡动画
   - 更好的视觉效果

4. **兼容性**
   - Android 4.1 兼容性测试
   - 不同屏幕尺寸适配
